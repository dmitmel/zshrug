use failure::*;
use std::fmt::Write;

use globset::{Glob, GlobSet, GlobSetBuilder};
use std::path::Path;
use walkdir::WalkDir;

use crate::config::Plugin;
use crate::storage::Storage;

pub fn generate(storage: &Storage, plugins: &[Plugin]) -> Fallible<String> {
  let mut script = String::new();

  macro_rules! write_script {
    ($($arg:tt)*) => {
      writeln!(script, $($arg)*).unwrap()
    };
  }

  macro_rules! write_block {
    ($name:expr, $body:block) => {
      write_script!("### {}", $name);
      $body
      write_script!("### end of {}", $name);
      write_script!();
    };
  }

  macro_rules! write_hook {
    ($name:expr, $body:expr) => {
      if !$body.is_empty() {
        write_block!($name, {
          write_script!("{}", $body);
        });
      }
    };
  }

  write_script!(
    "##### This script was generated by zshrug v{}",
    env!("CARGO_PKG_VERSION"),
  );
  write_script!();

  for plugin in plugins {
    write_script!("### plugin {:?} from {:?}", plugin.name, plugin.from);

    if !plugin.when.is_empty() {
      write_script!("if {}; then", plugin.when);
    }

    use std::borrow::Cow;
    let plugin_dir: Cow<Path> = storage.plugin_dir(&plugin);
    write_script!("zshrug_plugin_dir={}", zsh_quote_path(&plugin_dir));
    write_script!();

    write_hook!("before_load", plugin.before_load);

    write_block!("load", {
      let load = compile_patterns(&plugin.load)?;
      let ignore = compile_patterns(&plugin.ignore)?;

      for entry in WalkDir::new(&plugin_dir)
        .sort_by(|a, b| a.file_name().cmp(b.file_name()))
      {
        let entry: walkdir::DirEntry = entry.with_context(|_| {
          format!(
            "couldn't get plugin directory contents: {}",
            plugin_dir.display()
          )
        })?;

        let full_path = entry.into_path();
        let short_path = full_path.strip_prefix(&plugin_dir).unwrap();

        if load.is_match(&short_path) && !ignore.is_match(&short_path) {
          write_script!("source {}", zsh_quote_path(&full_path));
        }
      }
    });

    write_hook!("after_load", plugin.after_load);

    if !plugin.when.is_empty() {
      write_script!("fi");
    }
  }

  write_script!("unset zshrug_plugin_dir");

  Ok(script)
}

fn compile_patterns(patterns: &[String]) -> Fallible<GlobSet> {
  let mut builder = GlobSetBuilder::new();

  for pattern in patterns {
    let glob = Glob::new(&pattern)
      .with_context(|_| format!("couldn't compile glob: {}", pattern))?;
    builder.add(glob);
  }

  let glob_set = builder
    .build()
    .with_context(|_| format!("couldn't compile glob set: {:?}", patterns))?;

  Ok(glob_set)
}

fn zsh_quote_path(path: &Path) -> String {
  let path_str: String = path.display().to_string();
  format!("'{}'", path_str.replace('\'', "'\\''"))
}
