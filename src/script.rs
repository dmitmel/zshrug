use failure::*;
use std::fmt::Write;

use globset::{Glob, GlobSet, GlobSetBuilder};
use std::path::Path;
use walkdir::WalkDir;

use crate::config::{PathArrayChange, Plugin};
use crate::storage::Storage;

const PLUGIN_PATH_VAR_NAME: &str = "zshrug_plugin_path";

pub fn generate(storage: &Storage, plugins: &[&Plugin]) -> Fallible<String> {
  let mut script = String::new();

  macro_rules! write_script {
    ($($arg:tt)*) => {
      writeln!(script, $($arg)*).unwrap()
    };
  }

  macro_rules! write_block {
    ($name:expr, $body:block) => {
      write_script!("### {}", $name);
      $body
      write_script!("### end of {}", $name);
      write_script!();
    };
  }

  macro_rules! write_hook {
    ($name:expr, $body:expr) => {
      if !$body.is_empty() {
        write_block!($name, {
          write_script!("{}", $body);
        });
      }
    };
  }

  macro_rules! write_array_changes {
    ($var:expr, $changes:expr) => {
      if !$changes.is_empty() {
        write_block!($var, {
          for change in &$changes {
            use self::PathArrayChange::*;
            match change {
              Append(value) => {
                write_script!(
                  "{var}=(${var} \"$zshrug_plugin_path/\"{val})",
                  var = $var,
                  val = zsh_quote_str(value)
                );
              }
              Prepend(value) => {
                write_script!(
                  "{var}=(\"$zshrug_plugin_path/\"{val} ${var})",
                  var = $var,
                  val = zsh_quote_str(value)
                );
              }
            }
          }
        });
      }
    };
  }

  write_script!(
    "##### This script was generated by zshrug v{}",
    clap::crate_version!()
  );
  write_script!();

  for plugin in plugins {
    write_script!("### plugin {:?} from {:?}", plugin.name, plugin.from);

    if !plugin.when.is_empty() {
      write_script!("if {}; then", plugin.when);
    }

    use std::borrow::Cow;
    let plugin_dir: Cow<Path> = storage.plugin_dir(&plugin);
    write_script!("{}={}", PLUGIN_PATH_VAR_NAME, zsh_quote_path(&plugin_dir));
    write_script!();

    write_hook!("before_load", plugin.before_load);

    write_block!("load", {
      let load = compile_patterns(&plugin.load)?;
      let ignore = compile_patterns(&plugin.ignore)?;

      for entry in WalkDir::new(&plugin_dir)
        .sort_by(|a, b| a.file_name().cmp(b.file_name()))
      {
        let entry: walkdir::DirEntry = entry.with_context(|_| {
          format!(
            "couldn't get plugin directory contents: {}",
            plugin_dir.display()
          )
        })?;

        let full_path = entry.into_path();
        let short_path = full_path.strip_prefix(&plugin_dir).unwrap();

        if load.is_match(&short_path) && !ignore.is_match(&short_path) {
          write_script!(
            "source \"$zshrug_plugin_path/\"{}",
            zsh_quote_path(&short_path)
          );
        }
      }
    });

    write_array_changes!("path", plugin.path);
    write_array_changes!("fpath", plugin.fpath);
    write_array_changes!("manpath", plugin.manpath);

    write_hook!("after_load", plugin.after_load);

    if !plugin.when.is_empty() {
      write_script!("fi");
    }
  }

  write_script!("unset {}", PLUGIN_PATH_VAR_NAME);

  Ok(script)
}

fn compile_patterns(patterns: &[String]) -> Fallible<GlobSet> {
  let mut builder = GlobSetBuilder::new();

  for pattern in patterns {
    let glob = Glob::new(&pattern)
      .with_context(|_| format!("couldn't compile glob: {}", pattern))?;
    builder.add(glob);
  }

  let glob_set = builder
    .build()
    .with_context(|_| format!("couldn't compile glob set: {:?}", patterns))?;

  Ok(glob_set)
}

fn zsh_quote_path(path: &Path) -> String {
  let path_str: String = path.display().to_string();
  zsh_quote_str(&path_str)
}

fn zsh_quote_str(s: &str) -> String {
  format!("'{}'", s.replace('\'', "'\\''"))
}
